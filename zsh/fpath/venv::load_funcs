#!/usr/bin/env zsh

# --- venv functions

function venv__ensure_exists
{
  local venv_dir="${1:-venv}"

  if ! [[ -d "$venv_dir" ]]; then
    >&2 echo "ERROR: '$venv_dir' directory does NOT exist"
    return 1
  fi
}

function venv__ensure_inside
{
  if [[ -z "$VIRTUAL_ENV" ]]; then
    >&2 echo "ERROR: not in a virtual env"
    return 1
  fi
}

function venv__ensure_outside
{
  if [[ -n "$VIRTUAL_ENV" ]]; then
    >&2 echo "Deactivating active virtual env.."
    deactivate
  fi
}

function venv_init
{
  local venv_dir="${1:-venv}"

  if [[ -d "$venv_dir" ]]; then
    >&2 echo "ERROR: '$venv_dir' directory already exists"
    return 1
  fi

  python -m venv -- "$venv_dir"
}

function venv_on
{
  local venv_dir="${1:-venv}"

  venv__ensure_outside

  if ! venv__ensure_exists "$venv_dir"; then
    >&2 echo "  Use venv_init to create a venv there."
    return 1
  fi

  source "$venv_dir/bin/activate"
}

function venv_off
{
  venv__ensure_inside "$venv_dir" || return 1

  deactivate
}

function venv_do
{
  # NOTE: here venv_dir is assumed to be "venv"

  venv_on || return 1

  local ret=0
  "$@" || ret=$?

  venv_off
  return $ret
}

# Helper to activate a venv, deactivating an existing one and
# creating it if necessary.
function venv_here
{
  local venv_dir="${1:-venv}"

  venv__ensure_outside

  if ! [[ -d "$venv_dir" ]]; then
    >&2 echo "Venv directory '$venv_dir' missing, creating venv now.."
    venv_init "$venv_dir" || return 1
  fi

  >&2 echo "Enabling virtual env.."
  venv_on "$venv_dir"
}

# Helper to reset a venv, deactivating an existing one and recreate
# the whole virtual env.
function venv_reset
{
  local venv_dir="${1:-venv}"

  venv__ensure_outside

  if [[ -d "$venv_dir" ]]; then
    >&2 echo "Resetting existing virtual env in directory '$venv_dir'.."
    python -m venv --clear -- "$venv_dir"

    >&2 echo "Enabling virtual env.."
    venv_on "$venv_dir"
  else
    venv_here "$venv_dir"
  fi
}

# Disable pip unless in a virtual env or --my-env is passed
function pip
{
  if [[ "$1" == "--my-env" ]]; then
    shift
    >&2 echo "NOTE: if a virtual env is currently active, you'll change that env not your user's."
    command pip "$@"
    return $?
  fi

  if [[ -n "$VIRTUAL_ENV" ]] && [[ `type -p pip` =~ "$VIRTUAL_ENV/bin/pip" ]]; then
    command pip "$@"
    return $?
  fi
  >&2 echo "Nope! 'pip' is disabled globally, use 'pip-my-env' to manage packages in the user env"
  return 1
}
alias pip-my-env="pip --my-env"

# This function only needs to exist, when I call it, this file
# will get executed and the helper functions will be in scope.
function venv::load_funcs
{
  >&2 echo "Helper functions already loaded"
}
echo "Helper functions loaded!"
