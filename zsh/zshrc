#
#                     oooo                                         .o88o.
#                     `888                                         888 `"
#   oooooooo  .oooo.o  888 .oo.    .ooooo.   .ooooo.  ooo. .oo.   o888oo
#  d'""7d8P  d88(  "8  888P"Y88b  d88' `"Y8 d88' `88b `888P"Y88b   888
#    .d8P'   `"Y88b.   888   888  888       888   888  888   888   888
#  .d8P'  .P o.  )88b  888   888  888   .o8 888   888  888   888   888
# d8888888P  8""888P' o888o o888o `Y8bod8P' `Y8bod8P' o888o o888o o888o
#

# BIN_* vars are used to specify the binary dependencies of this config file.
# NOTE: These lines may be rewritten by config manager.
_BIN_dircolors=dircolors

# _ZSH_PLUGIN_SRCREF_* vars are used to specify from where the plugin should be init from
# (may be a path for things that are sourced, may be a org/repo for things that reference a GH repo)
# NOTE: These lines may be rewritten by config manager.
_ZSH_PLUGIN_SRCREF__zsh_hooks=$ZSH_MY_CONF_DIR/third-party/zsh-hooks
_ZSH_PLUGIN_SRCREF__zi=$ZSH_MY_CONF_DIR/third-party/zi
_ZSH_PLUGIN_SRCREF__F_Sy_H=z-shell/F-Sy-H
_ZSH_PLUGIN_SRCREF__z=rupa/z
_ZSH_PLUGIN_SRCREF__autopair=hlissner/zsh-autopair
_ZSH_PLUGIN_SRCREF__gitstatus=romkatv/gitstatus
_ZSH_PLUGIN_SRCREF__zconvey=z-shell/zconvey

# colors for common binaries (ls, tree, etc..)
#
# NOTE: must be done early (not sure why)
if command -v $_BIN_dircolors >/dev/null; then
  eval `dircolors --sh`
fi

#-------------------------------------------------------------
# Setup Hooks

# better zsh-hooks
source $_ZSH_PLUGIN_SRCREF__zsh_hooks/zsh-hooks.plugin.zsh

## ZSH HOOKS

# precmd_hook
hooks-define-hook precmd_hook
function precmd-wrapper { hooks-run-hook precmd_hook }
add-zsh-hook precmd precmd-wrapper

# preexec_hook
hooks-define-hook preexec_hook
function preexec-wrapper { hooks-run-hook preexec_hook "$@" }
add-zsh-hook preexec preexec-wrapper

# chpwd_hook
hooks-define-hook chpwd_hook
function chpwd-wrapper { hooks-run-hook chpwd_hook }
add-zsh-hook chpwd chpwd-wrapper

#-------------------------------------------------------------
# Load and configure plugins

# zi (old project names: zinit, zplugin)
# WARNING: needs folder ~/.zi to exist, it will auto download/setup plugins on first launch
source $_ZSH_PLUGIN_SRCREF__zi/zi.zsh

# Syntax highlighting
FAST_WORK_DIR=$ZSH_DATA_DIR/plugin--fast-syntax-highlighting
mkdir -vp "$FAST_WORK_DIR" # necessary to exist, other it falls back to ~/.cache :/
# | => to avoid the selected theme to be saved in ~/.cache tmpfs (empty on boot)
# \__ ref: https://github.com/z-shell/F-Sy-H/issues/25 (by me)
zi light $_ZSH_PLUGIN_SRCREF__F_Sy_H # updated repo for fast-syntax-highlighting
# Note: to activate/update my custom theme, run:
#   fast-theme $ZSH_MY_CONF_DIR/fast-theme--bew.ini
# TODO: 

# cd with 'frecency' (recent + frequence)
zi light $_ZSH_PLUGIN_SRCREF__z

# autopair all the things!
# don't auto-init before setting my key bindings, init at the end (with 'autopair-init')
AUTOPAIR_INHIBIT_INIT=1
zi light $_ZSH_PLUGIN_SRCREF__autopair

# Git branch in prompt (using fast gitstatusd daemon)
GITSTATUS_CACHE_DIR=$ZSH_DATA_DIR/plugin--gitstatus
# \__ to avoid binary auto install in ~/.cache tmpfs (empty on boot)
zi light $_ZSH_PLUGIN_SRCREF__gitstatus
gitstatus_start MY

# Ability to send command between shells :)
zi ice wait"0" silent # load plugin async & silently
zi light $_ZSH_PLUGIN_SRCREF__zconvey
zstyle ":plugin:zconvey" greeting "none"

#-------------------------------------------------------------
# remember recent directories (use with 'cdr')
autoload -Uz cdr
# Store chpwd file in a shared dir across all zsh configs,
# and use other files if our file is less filled than the others.
zstyle ':chpwd:*' recent-dirs-file \
  "$ZSH_DATA_DIR_SHARED/chpwd-recent-dirs-${ZSH_CONFIG_ID}" \
  "$ZSH_DATA_DIR_SHARED/chpwd-recent-dirs-*"

# The original chpwd_recent_dirs (from autoload) doesn't work when the
# chpwd hook is called after a non-toplevel `cd`, e.g when we `cd` from a script
# or a function.
#
# This chpwd_recent_dirs adds a way to force the hook to run, when $HOOK_LIKE_TOPLEVEL
# is defined.
#
# It allows you to write:
#
#   HOOK_LIKE_TOPLEVEL=1 hooks-run-hook chpwd_hook
#
# to run the hooks related to chpwd_hook, forcing their execution (at least for
# chpwd_recent_dirs).
function chpwd_recent_dirs
{
    emulate -L zsh
    setopt extendedglob
    local -aU reply
    integer changed
    autoload -Uz chpwd_recent_filehandler chpwd_recent_add

    # BEGIN ADDITION
    local is_toplevel_or_forced=1
    if [[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT != toplevel(:[a-z]#func|)# ]]; then
        # not called from toplevel (=> script)
        is_toplevel_or_forced=0
        if [[ -n "$HOOK_LIKE_TOPLEVEL" ]]; then
            is_toplevel_or_forced=1
        fi
    fi

    [[ $is_toplevel_or_forced == 0 ]] && return
    # END ADDITION

    if [[ ! -o interactive || $ZSH_SUBSHELL -ne 0 ]]; then
        return
    fi
    chpwd_recent_filehandler
    if [[ $reply[1] != $PWD ]]; then
        chpwd_recent_add $PWD && changed=1
        (( changed )) && chpwd_recent_filehandler $reply
    fi
}
hooks-add-hook chpwd_hook chpwd_recent_dirs

#-------------------------------------------------------------
# Options
source $ZSH_MY_CONF_DIR/rc/options.zsh

#-------------------------------------------------------------
# Completion
source $ZSH_MY_CONF_DIR/rc/completions.zsh

#-------------------------------------------------------------
# Bracketed paste that adds an 'undo' point

# Override the default `bracketed-paste` widget, triggered when an external paste
# is incoming to the shell.
function my-bracketed-paste-with-undo
{
  # Add an undo mark before receiving the pasted-content, so that the paste can
  # be easily undo-able without loosing anything I might have written before.
  zle split-undo

  # do normal paste
  zle .bracketed-paste
}
zle -N bracketed-paste my-bracketed-paste-with-undo


#-------------------------------------------------------------
# Default directory aliases

hash -d dot=$(realpath ~/.dot)
hash -d cfg=~/.config
hash -d pkgs=~/.nix-home-current/nixpkgsStable

#-------------------------------------------------------------
# Aliases
source $ZSH_MY_CONF_DIR/rc/aliases_and_short_funcs.zsh

#-------------------------------------------------------------
# Prompt

source $ZSH_MY_CONF_DIR/rc/prompt.zsh

#-------------------------------------------------------------
# Keybinds
source $ZSH_MY_CONF_DIR/rc/mappings.zsh

#-------------------------------------------------------------
# Terminal title
# source $ZSH_MY_CONF_DIR/rc/terminal_title.zsh
# Disabled for now, It kinda breaks when SHLVL > 1, and I'm not even sure it works :eyes:
# (and I don't really miss it)

#-------------------------------------------------------------
# SSH Agent handling
# DISABLED, I don't use the ssh agent anymore..
#source $ZSH_MY_CONF_DIR/rc/ssh_agent.zsh


#-------------------------------------------------------------
# Functions

fpath=($ZSH_MY_CONF_DIR/fpath $fpath)

# Switch terminal colors dark/light at runtime
function switch-term-colors
{
  local color_mode=$(command switch-term-colors "$@")
  if [[ "$color_mode" =~ "Usage" ]]; then
    echo "$color_mode" # print error
    return 1
  else
    export TERM_COLOR_MODE="$color_mode"
  fi
}

# ------------------------------------------------------------
# Media helper funcs

# DISABLED: these shouldn't be zsh functions, but external scripts!

#autoload -U ffmpeg::load_funcs
#
#autoload -U mpv::load_funcs
#alias tv-start='mpv::start-daemon tv --no-terminal --force-window'
#alias tv-add='mpv::add-media tv'

#-------------------------------------------------------------
# MISC - not sure where to put these...

# Import zsh's massive rename helper
autoload -U zmv
alias zmv='noglob zmv'
alias zcp='zmv -C'
alias zln='zmv -L'
alias zmv::dry-run='zmv -n'
alias zcp::dry-run='zcp -n'
alias zln::dry-run='zln -n'


#-------------------------------------------------------------
# LATE INIT - initialize things that should be init last

autopair-init

#-------------------------------------------------------------
# Load local per-machine zsh config
# TODO: rework to be more flexible?

[[ -f ~/.zshrc.local ]] && source ~/.zshrc.local

true # The config should always finish well!
