# definitions

snippet cl "class definition" b
class ${10:MyClass}${20:(${21:object})}:
	${30:${VISUAL:pass}}
endsnippet

snippet data "Dataclass definition" b
@dataclass$10
class ${20:MyClass}:
	${30:${VISUAL:pass}}
endsnippet

snippet def "function" b
def ${10:function_name}(${20:self${21:, ${22:arg}}})${30: -> ${31:Any}}:
	${40:${VISUAL:pass}}
endsnippet

snippet defi "initializer" b
def __init__(self${10:, ${11:arg}}):
	${20:${VISUAL:pass}}
endsnippet

snippet defa "abstract method" b
@abstractmethod
def ${10:function_name}(self${20:, ${21:arg}})${30: -> ${31:Any}}:  # pragma: no cover
	pass
endsnippet

snippet defap "abstract property" b
@abstractproperty
def ${10:function_name}(self) -> ${20:Any}:  # pragma: no cover
	pass
endsnippet

snippet defc "class method" b
@classmethod
def ${10:function_name}(cls${20:, ${21:arg}})${30: -> ${31:Any}}:
	${40:${VISUAL:pass}}
endsnippet

snippet defs "static method" b
@staticmethod
def ${10:function_name}(${20:arg})${30: -> ${31:Any}}:
	${40:${VISUAL:pass}}
endsnippet

snippet defp "property method" b
@property
def ${10:function_name}(self) -> ${20:Any}:
	${30:${VISUAL:pass}}
endsnippet

snippet deft "test function" b
def test_${10:something_is_working}($20):
	${30:${VISUAL:pass}}
endsnippet

snippet deftu "pytest unit test function" b
@pytest.mark.unit
def test_${10:something_is_working}($20):
	${30:${VISUAL:pass}}
endsnippet

snippet deftx "pytest fixture function" b
@pytest.fixture${1:(scope="${2:function}"${3:, autouse=True})}
def ${10:some_prefilled_obj}($20) -> ${30:Any}:
	${40:${VISUAL:pass}}
endsnippet

snippet pytu "pytest unit test decorator" b
@pytest.mark.unit
endsnippet

snippet pyts "pytest skip test decorator" b
@pytest.mark.skip  # TODO: remove this!
endsnippet

snippet pytp "pytest parametrize test decorator" b
@pytest.mark.parametrize(
	"${10:param1,param2}",
	[
		(${20:value1,value2}),$0
	],
)
endsnippet

snippet pytpi "pytest parametrize test decorator (inline)" b
@pytest.mark.parametrize("${10:param1,param2}", [$2])
endsnippet
# decorators

snippet @data "@dataclass" b
@dataclass
endsnippet

snippet @abc "@abstractmethod" b
@abstractmethod
endsnippet

snippet @cl "@classmethod" b
@classmethod
endsnippet

snippet @st "@staticmethod" b
@staticmethod
endsnippet

snippet @prop "@property" b
@property
endsnippet

# if / elif / else

snippet if "If" b
if ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet

snippet ife "If / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
else:
	${3:pass}
endsnippet

snippet elif "elif ..." b
elif ${1:condition}:
	${2:pass}
endsnippet

snippet el "else" b
else:
	${1:pass}
endsnippet

snippet ifmain "ifmain" b
if __name__ == "__main__":
	${1:${VISUAL:main()}}
endsnippet

# for

snippet for "for loop" b
for ${1:item} in ${2:iterable}:
	${3:${VISUAL:pass}}
endsnippet

# try

snippet try "Try / Except" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception}${3: as ${4:e}}:
	${5:raise $4}
endsnippet

# misc

snippet /""/ "triple quoted string (double quotes)" r
"""
${VISUAL}$1
"""
endsnippet

snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python3
endsnippet

snippet doc "One line doc" b
"""${1:${VISUAL:TODO: doc}}"""
endsnippet

snippet mdoc "Multi line doc" b
"""${1:TODO: oneline doc}
${2:${VISUAL:TODO: doc}}
"""
endsnippet

snippet p "print(...)" b
print(${1:${VISUAL}})
endsnippet

snippet pf "print(f-string...)" b
print(f"${1:${VISUAL}}"$2)
endsnippet

snippet pp "pprint(...)" b
from pprint import pprint; pprint(${1:${VISUAL}})  # noqa: E702 E402 E501
endsnippet

snippet f "f format str" w
f"$1"
endsnippet

snippet s "self.X = X" b
self.${1:name} = $1
endsnippet

snippet s_ "self._X = X" b
self._${1:name} = $1
endsnippet

snippet opt "Optional[...]"
Optional[${1:${VISUAL:SomeType}}]
endsnippet

snippet optn "Optional[...] = None"
Optional[${1:${VISUAL:SomeType}}] = None
endsnippet

snippet ld "lambda"
lambda
endsnippet

snippet nocov "pragma no cover"
# pragma: no cover
endsnippet

snippet ass "assert ..." b
assert $0
endsnippet

# NOTE: this can be necessary sometimes when the running process closes stdio
# __import__("sys").stdin = open('/dev/tty')
snippet bp "Add pdb breakpoint"
breakpoint()  # FIXME: remove this debug probe
endsnippet
snippet bpforce "Force add pdb breakpoint" b
__import__("sys").stdin = open('/dev/tty'); breakpoint()  # FIXME: remove this debug probe
endsnippet

# Increase priority of this 'rtype' snippet, to avoid conflict with the
# other 'rtype' snippet, used for reveal_type when the cursor is NOT at BOL
priority 10
snippet rtype "reveal_type" b
reveal_type(${0:${VISUAL:expr}})  # noqa
endsnippet
priority 0
snippet rtype "reveal_type (in expr)" w
reveal_type(${0:${VISUAL:expr}})
endsnippet

# vim:ft=snippets:
