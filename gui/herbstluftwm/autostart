#!/usr/bin/env bash

# this is a simple config for herbstluftwm

function hc {
    herbstclient "$@"
}

hc emit_hook reload

# reset keybind, mousebind, theme attr, rules
# FIXME: no way to reset options (set/get)?
hc keyunbind --all
hc mouseunbind --all
hc attr theme.reset 1
hc unrule -F

# keybindings
M=Mod4   # Use the super key as the main modifier
C=Control
S=Shift
A=Alt

# WM-level actions
hc keybind $M-$C-q   quit
hc keybind $M-$C-r   reload

# WM agnostic keys

# lock (& sleep)
hc keybind Pause   spawn ~/.bin/i3colocker
hc keybind $C-Pause   spawn ~/.bin/desktop--lock-and-sleep ~/.bin/i3colocker
# FIXME? (but how to fix?) the screen flashes with the 'theme.background_color' just
# before i3lock is displayed with a blurry screenshot.
# --> Seems to be related with the bash script starting i3lock. Starting i3lock
#     without script does not flicker.

hc keybind $M-space   spawn urxvt
hc keybind $M-$S-space spawn ~/.bin/wezterm
hc keybind $M-x       spawn rofi -show drun
# TODO: need an (interactive) action menu for chains: M-x space, M-x f, M-x t
# could also be used for window state (toggle on top, floating, ..)

# basic random wallpaper selection
hc keybind $M-w   spawn feh --recursive --bg-scale --randomize ~/wallpapers/

# volume management using pamixer
hc keybind $S-XF86AudioLowerVolume  spawn pamixer --decrease 1
hc keybind $S-XF86AudioRaiseVolume  spawn pamixer --increase 1
hc keybind XF86AudioLowerVolume     spawn pamixer --decrease 5
hc keybind XF86AudioRaiseVolume     spawn pamixer --increase 5

hc keybind XF86AudioMute      spawn pamixer --toggle-mute
hc keybind $M-XF86AudioMute   spawn pavucontrol # helper for sound settings

# TODO: add brightness keys
# TODO: add network pinger

# end of WM agnostic keys

# FIXME: how to implement window locking? (On $M-$C-l ?)

# basic movement
# focusing clients
hc keybind $M-h   focus left
hc keybind $M-j   focus down
hc keybind $M-k   focus up
hc keybind $M-l   focus right

# moving clients (inside a frame, or to the next frame in the given direction)
hc keybind $M-$S-h   shift left
hc keybind $M-$S-j   shift down
hc keybind $M-$S-k   shift up
hc keybind $M-$S-l   shift right

# splitting frames
# create an empty frame in the specified direction and focus it
hc keybind $M-$C-Left    chain , split left    0.5 , focus -e left
hc keybind $M-$C-Right   chain , split right   0.5 , focus -e right
hc keybind $M-$C-Down    chain , split bottom  0.5 , focus -e down
hc keybind $M-$C-Up      chain , split top     0.5 , focus -e up

# Splits the frame in such a way that the window sizes and positions are kept
# as much as possible.
# NOTE: When there are 3+ windows, the new frame is created after the focused window.
hc keybind $M-$C-e   split explode

# Remove a frame
hc keybind $M-r   remove # FIXME: $M-$C-r is already "reload!"

# FIXME: what is the workflow (and minimal keys) I want, to:
# - open a terminal quickely somewhere specific
# - move a window to somewhere specific
# - move a window to another tag/monitor (tag: done!)
# - open scratch terminal (using a monitor? with special mappings to layouting (ex: max))
# move a frame somewhere else (to another tag? --> does it even make sense?)

# Move focus between frames
#
# Make sure that a floating client stays focused if it was.
function bind_frame_focus
{
  local keybind="$1"
  local dir="$2"
  # this is basically:
  # if focused_client.floating:
  #   stop focusing floating layer
  #   focus a frame in the given direction
  #   start focusing floating layer (last focused client)
  # else:
  #   focus a frame in the given direction
  hc keybind "$keybind" \
    or  , and . compare clients.focus.floating = "true" \
              . chain : lock \
                      : attr tags.focus.floating_focused false \
                      : focus -e "$dir" \
                      : attr tags.focus.floating_focused true \
                      : unlock \
        , focus -e "$dir"
}
bind_frame_focus $M-$C-h   left
bind_frame_focus $M-$C-j   down
bind_frame_focus $M-$C-k   up
bind_frame_focus $M-$C-l   right


# Close current window
hc keybind $M-$S-c   close

# tags
tag_names=( {1..9} )
tag_keys=( {1..9} 0 )

hc rename default "${tag_names[0]}" || true
for i in ${!tag_names[@]} ; do
  hc add "${tag_names[$i]}"
  key="${tag_keys[$i]}"
  hc echo $key
  if ! [ -z "$key" ] ; then
    hc keybind "$M-$key" use_index "$i"
    hc keybind "$M-$S-$key" move_index "$i"
  fi
done

# FIXME: how to implement dynamic tags (with traversing)
#   What about tag groups? (would need a special keymap to navigate groups..
#   not enough keys otherwise)

# cycle through tags (skip already visible tags on another monitor)
# NOTE: would need to change if I want to insert tags anywhere, since hlwm
#       does not support insertion (yet) I can't use the 'linear' use_index +1 -1.
hc keybind $M-a   use_index -1 --skip-visible
hc keybind $M-z   use_index +1 --skip-visible

# Move window to prev/next tag and make it floating (so I can place it where I want)
hc keybind $M-$S-a \
  chain , attr clients.focus.floating true \
        , move_index -1 \
        , use_index -1 --skip-visible
hc keybind $M-$S-z \
  chain , attr clients.focus.floating true \
        , move_index +1 \
        , use_index +1 --skip-visible

hc keybind $M-$A-r   spawn ~/.config/herbstluftwm/scripts/hlwm_rename_current_tag.py

# layouting

# Toggle floating state.
# Note that when floating is turned off, the window will be inserted in the currently
# selected frame, not its original frame.
hc keybind $M-f   attr clients.focus.floating toggle
# FIXME: would it make sense to have a way to remember the parent frame?

hc keybind $M-$C-m   fullscreen toggle # fullscreen current client
# hc keybind $M-$C-f floating toggle # all clients of current tag become floating (and stacked..)

# if frame layout is not max
#   remember current frame layout (in the frame attr system?)
#   switch to max
# else
#   switch back to saved frame layout
# end
# FIXME: how to do this???
# hc keybind $M-m \
#   or , and . compare frames.focus.layout   # !! frames object does not exist...

# NOTE: for now we only cycle between max & vertical. So if the layout was horizontal
# I'll have to re-do select horizontal after going maximized
# It seems that if it's horizontal it'll first select vertical, them max >< oh well..
hc keybind $M-m   cycle_layout +1 max vertical

# Cycle through frame layouts, skipping 'max' layout (which is toggled by another key).
#   - layouts for 2 clients: vertical, horizontal
#   - layouts for 1 or 3+ clients: vertical, horizontal, grid
hc keybind $M-s                                      \
  or , and . compare tags.focus.curframe_wcount = 2  \
           . cycle_layout +1 vertical horizontal     \
     , cycle_layout +1 vertical horizontal grid
# FIXME: Will need a way to see the current frame layout 'somewhere' (maybe on demand)

# mouse

# NOTE: Does nothing for tiled windows
hc mousebind $M-Button1   move

# Resize non-empty frames and floating windows
hc mousebind $M-Button3   resize

# Resizes the window into all four directions while keeping the center of the
# window constant (at the same place).
hc mousebind $M-$S-Button3   zoom

# focus
hc keybind $M-BackSpace   cycle_monitor

hc keybind $M-Tab      cycle_all +1   # FIXME: I want to select the LAST window.. not possible builtin..
hc keybind $M-$S-Tab   cycle_all -1
hc keybind $M-c   cycle
hc keybind $M-u   jumpto urgent

# theme

# a frame has a border, then some permanent lines for the frame's rectangle.
# since I cannot remove those lines and keep only the borders, I hide the borders.
hc set frame_border_width 0
hc set frame_border_active_color "#f00"
hc set frame_border_normal_color "#00f"

# If set, all frames are displayed.
# If unset, only frames with focus or with windows in them are displayed.
# NOTE: the frame in question is the frame's border, which is the only visible
# thing when the frame is empty.
hc set always_show_frame 1

hc set frame_bg_normal_color "#565656"
hc set frame_bg_active_color "#aaaaaa"
hc set frame_bg_transparent 1
hc set frame_transparent_width 3
hc set frame_gap 0
hc set frame_padding 10

# FIXME: why are there xyz_border_width options and theme.xyz.border_width attributes ????
# also I don't get the usage for sooo many borders (inner -> border -> outer)
hc attr theme.active.color "#33B5E5"
hc attr theme.normal.color "#171717"
hc attr theme.urgent.color orange
hc attr theme.border_width 5
hc attr theme.background_color "#FFFFFF"

hc set window_gap 5
hc set smart_window_surroundings 0
hc set smart_frame_surroundings 1
hc set mouse_recenter_gap 0

# If set, a client’s window content is resized immediately during resizing it
# with the mouse. If unset, the client’s content is resized after the mouse
# button is released.
hc set update_dragged_clients 1

hc set focus_follows_mouse true
hc set raise_on_focus false
hc set raise_on_focus_temporarily false

# rules
#hc rule class=XTerm tag=3 # move all xterms to tag 3
hc rule focus=on # normally focus new clients

hc rule --windowtype~"_NET_WM_WINDOW_TYPE_(DIALOG|UTILITY|SPLASH)" floating=on
hc rule --windowtype="_NET_WM_WINDOW_TYPE_DIALOG" focus=on
hc rule --windowtype~"_NET_WM_WINDOW_TYPE_(NOTIFICATION|DOCK|DESKTOP)" manage=off

hc rule --instance="pavucontrol" floating=true floatplacement=center

hc rule --instance="yad" floating=true

hc rule --instance~".*kazam.*" floating=true

# unlock, just to be sure
hc unlock

herbstclient set tree_style "╾│ ├└╼─┐"

# -- multi monitor setup (making a monitor per physical display)
# hc set_monitors 1280x1024+0+0 1280x1024+1280+0
# or simply:
# hc detect_monitors
